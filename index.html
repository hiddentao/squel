<!DOCTYPE html>
<html>
<head>
    <title>Squel.js - SQL query string builder for Javascript</title>

    <meta name="keywords" content="sql,javascript,nodejs,orm,mysql,github,vowsjs,coffeescript" />
    <meta name="description" content="Squel is a compact, lightweight Javascript library for building SQL query strings, usable with node.js or in the browser." />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1.0, user-scalable=0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">

    <link href='http://fonts.googleapis.com/css?family=Bree+Serif' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Armata' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" media="screen, projection" href="public/css/shCoreRDark.css" />
    <link rel="stylesheet" type="text/css" media="screen, projection" href="public/css/screen.css" />
    <link rel="stylesheet" type="text/css" media="print" href="public/css/print.css" />
    <!--[if IE]>
        <link rel="stylesheet" type="text/css" media="screen, projection" href="public/css/ie.css" />
    <![endif]-->


</head>
<body>

    <a id="github" href="https://github.com/hiddentao/squel">
      <span>Fork me on GitHub!</span>
      <span>I love you :-)</span>
    </a>

    <header>
        <div id="logo">Squel.js</div>
        <nav>
            <ul>
                <li><a href="#home" title="Home">Home</a></li>
                <li>
                    <a href="#docs" title="View documentation">Docs</a>
                    <ul class="submenu">
                        <li><a href="#installation" title="Installation instructions">Installation</a></li>
                        <li><a href="#overview" title="Overview">Overview</a></li>
                        <li><a href="#select" title="SELECT queries">SELECT</a></li>
                        <li><a href="#update" title="UPDATE queries">UPDATE</a></li>
                        <li><a href="#insert" title="INSERT queries">INSERT</a></li>
                        <li><a href="#delete" title="DELETE queries">DELETE</a></li>
                        <li><a href="#autoquotes" title="Automatic quotes">Automatic quotes</a></li>
                        <li><a href="#expressions" title="SQL expressions">Expressions</a></li>
                        <li><a href="#cloning" title="Cloning">Cloning</a></li>
                        <li><a href="#custom" title="Custom queries">Custom queries</a></li>
                    </ul>
                </li>
                <li><a href="#tests" title="Running the tests">Tests</a></li>
                <li><a class="external" href="http://prezi.com/8fdvjo6ripkw/squeljs/" title="View the presentation">Prezi</a></li>
            </ul>
        </nav>
    </header>

    <section id="home">
        <a name="home"></a>

        <div class="left white_text">
            <p class="heading">Squel.js</p>
            <p class="sub">- lightweight Javascript library for building SQL query strings.</p>
            <p class="sub">- usable with node.js or in the browser.</p>
            <p class="sub">- well tested (~ 240 <a href="http://visionmedia.github.com/mocha/" title="Mocha">Mocha</a> tests).</p>
        </div>

        <div class="right">
            <p class="npm">
                npm install squel
            </p>
            <a class="prod" href="https://raw.github.com/hiddentao/squel/master/squel.min.js" title="Download production version">
                <p class="label">Production version</p>
                <p class="stats">(~3.6 KB minified + gzipped)</p>
            </a>
            <a class="dev" href="https://raw.github.com/hiddentao/squel/master/squel.js" title="Download development version">
                <p class="label">Development version</p>
                <p class="stats">(~27 KB)</p>
            </a>
        </div>

    </section>

    <a name="docs"></a>
    <section id="installation" class="white_text">
        <a name="installation" href="#installation"><h2>Installation</h2></a>

        <h3>Node.js</h3>

        <p>To install for node.js use <code>npm</code>:</p>

        <pre class="brush: shell">npm install squel</pre>

        <p>Once done you can use <code>require</code> to access the API:</p>

        <pre class="brush: js">var squel = require("squel");</pre>

        <h3>Browser</h3>

        <p>To use within a webpage include the following within your HTML <code>body</code> section, near the bottom:</p>

        <pre class="brush: html">&lt;script type="text/javascript" src="/your/path/to/squel.min.js"&gt;&lt;/script&gt;</pre>

        <p>Once loaded the <code>squel</code> API will be available in the global object:</p>

        <pre class="brush: js">alert( typeof window.squel );    // object</pre>

        <p class="warning">NOTE: It is recommended that you do NOT create queries browser-side to run on the
          server as this massively increases your exposure to <a href="http://en.wikipedia.org/wiki/SQL_injection" target="_blank">SQL Injection</a> attacks.</p>

    </section>

    <section id="overview">
        <a name="overview" href="#overview"><h2>Overview</h2></a>

        <p><code>Squel</code> helps you quickly and easily build SQL query strings through an object oriented API.
            There are two main benefits to using Squel to build your queries:</p>

        <ol>
            <li><strong>It requires less effort</strong> - instead of having to use brittle methods like string
                concatenation and substitution you get a nice clean API to do the hard work for you.</li>
            <li><strong>It lets you build flexibly</strong> - Sometimes you don't yet know what your final query ought
                to look like until you've checked information from various other parts of your program. Representing the
            query as an object which can be manipulated allows you to be flexible about how you build it.</li>
        </ol>

        <p>Ok, now you're convinced! Before you get stuck in here are a few things to be aware of...</p>

        <p>Squel uses <a href="http://en.wikipedia.org/wiki/Method_chaining">method chaining</a> to
            make things easy. For example, instead of writing:</p>

        <pre class="brush: js">
            var s = squel.select();
            s.from("student");
            alert( s.toString() );    /* SELECT * FROM student */
        </pre>

        <p><em>Hint: You can run the example above by clicking it!</em></p>

        <p>You can simply write:</p>

        <pre class="brush: js">
            alert( squel.select().from("students").toString() );  // SELECT * FROM students
        </pre>

        What's even better, the <code>toString()</code> method gets called automatically by the Javascript interpreter
        whenever a string representation of an object is needed. So we can actually simplify the previous statement to:

        <pre class="brush: js">
            alert( squel.select().from("students") );  /* SELECT * FROM students */
        </pre>

        <p><em>Note: All of Squel's builders provide the <code>toString()</code> method. It is this
            method which constructs the final query string.</em></p>

        <p>Squel does not check to see if your final query is semantically correct (i.e. that it makes
            sense). Your database engine already does a good enough job of that. On the plus side Squel allows you
            to use proprietary database functions and other complex constructs:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .field("name")
                    .field("MIN(test_score)")
                    .field("MAX(test_score)")
                    .field("GROUP_CONCAT(DISTINCT test_score ORDER BY test_score DESC SEPARATOR ' ')")
                    .group("name")
            );
            /*
                SELECT
                    name,
                    MIN(test_score),
                    MAX(test_score),
                    GROUP_CONCAT(DISTINCT test_score ORDER BY test_score DESC SEPARATOR ' ')
                FROM
                    students
                GROUP BY
                    name
            */
        </pre>

        <p><em>Note: Unless stated otherwise all query builder methods require string arguments. Passing in objects,
            arrays or functions will result in exceptions being thrown.</em></p>


    </section>

    <section id="select">
        <a name="select" href="#select"><h2>SELECT</h2></a>

        <p>To get an instance of the <code>SELECT</code> query builder:</p>

        <pre class="brush: js">
            var q = squel.select();
        </pre>

        <p>Calling <code>toString()</code> on it now will throw an exception:</p>

        <pre class="brush: js">
            try {
                alert( squel.select() );  /* remember that toString() is implicitly called here */
            } catch (error) {
                alert( error ); /* from() needs to be called */
            }
        </pre>

        <p>Thus, at a minimum the name of a table to fetch data from must be provided:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
            );
            /* SELECT * FROM students */
        </pre>

        <h3>Multiple tables</h3>

        <p>You can select data from multiple tables and provide aliases where needed:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .from("lecturers", "l")
                    .from("admins")
            );
            /* SELECT * FROM students, lecturers `l`, admins */
        </pre>

        <h3>Fields</h3>

        <p>You can specify field names on their own or by the table they belong to:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .field("id")
                    .field("students.name")
            );
            /* SELECT id, students.name FROM students */
        </pre>

        <p>Field names can be given aliases in order to customize the column names in the query results :</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .field("id", "Id")
                    .field("students.name", "Student Name")
            );
            /* SELECT id AS "Id", students.name AS "Student Name" FROM students */
        </pre>

        <p>Database functions can be used in place of field names for more complex results:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students", "s")
                    .field("s.id")
                    .field("s.test_score", "Test score")
                    .field("DATE_FORMAT(s.date_taken, '%M %Y')", "Taken on")
            );
            /*
                SELECT
                    s.id,
                    s.test_score AS "Test score"
                    DATE_FORMAT(s.date_taken, '%M %Y') AS "Taken on"
                FROM
                    students `s`
            */
        </pre>

        <p>If you wish to obtain <code>DISTINCT</code> results you can do so:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .field("id")
                    .distinct()
            );
            /*  SELECT DISTINCT id FROM students    */
        </pre>

        <h3>Joins</h3>

        Squel supports <code>INNER</code>, <code>OUTER</code>, <code>LEFT</code> and <code>RIGHT</code> joins. To do an
        <code>INNER</code> join:

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .join("teachers")
            );
            /*  SELECT * FROM students INNER JOIN teachers */
        </pre>

        You can specify table aliases:

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .join("teachers", "t")
                    .outer_join("expelled")
            );
            /*  SELECT * FROM students
                    INNER JOIN teachers `t`
                    OUTER JOIN expelled
            */
        </pre>

        And you can specify JOIN-ing conditions:

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("students.id")
                    .from("students")
                    .left_join("teachers", null, "students.id = teachers.student_id")
                    .right_join("jailed", "j", "j.student_id = students.id")
            );
            /*  SELECT students.id FROM students
                    LEFT JOIN teachers ON (students.id = teachers.student_id)
                    RIGHT JOIN jailed `j` ON (j.student_id = students.id)
            */
        </pre>

        <p><em>For an optional parameter such as an alias name, passing <code>null</code> is the same as omitting it.</em></p>

        <h3>Filtering</h3>

        <p>You can add <code>WHERE</code> clause filtering to your query very easily:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .where("name = 'Thomas'")
            );
            /*  SELECT id FROM students WHERE (name = 'Thomas')  */
        </pre>

        <p><code>WHERE</code> clauses support parameter substitutions:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .where("name = ? and age > ?", 'Thomas', 18)
            );
            /*  SELECT id FROM students WHERE (name = 'Thomas' and age = 18)  */
        </pre>

        <p>Array values can be used to create in clauses:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .where("age in ?", [18, 19, 20])
            );
            /*  SELECT id FROM students WHERE (age in (18, 19, 20))  */
        </pre>

        <p>Multiple filters are automatically combined using <code>AND</code>:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .where("name = 'Thomas'")
                    .where("age > 18")
            );
            /*  SELECT id FROM students WHERE (name = 'Thomas') AND (age > 18)  */
        </pre>

        <p>Also filter using <code>OR</code> or any other operator you like:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .where("name = 'Thomas' OR age > 18")
                    .where("id BETWEEN 200 and 300")
            );
            /*  SELECT id FROM students WHERE (name = 'Thomas' OR age > 18) AND (id BETWEEN 200 and 300) */
        </pre>

        <p>You can also pass in <a href="#expressions">Expressions</a>:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .where(
                        squel.expr().and("name = 'Thomas'").or("age > 18")
                    )
            );
            /*  SELECT id FROM students WHERE (name = 'Thomas' OR age > 18) */
        </pre>

        <h3>Sorting</h3>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .order("id")
                    .order("name")
            );
            /*  SELECT id FROM students ORDER BY id ASC, name ASC */
        </pre>

        <p>Use the second argument of <code>order()</code> to change the direction of a sort:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .order("id")
                    .order("name", false)  /* using TRUE instead would be the same as omitting it. */
            );
            /*  SELECT id FROM students ORDER BY id ASC, name DESC */
        </pre>

        <h3>Grouping</h3>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .group("id")
            );
            /*  SELECT id FROM students GR0UP BY id */
        </pre>

        <p>Grouping on multiple fields is supported:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("id")
                    .from("students")
                    .group("id")
                    .group("students.name")
            );
            /*  SELECT id FROM students GR0UP BY id, students.name */
        </pre>

        <h3>Ranges</h3>

        <p>To <code>LIMIT</code> the number of results:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .limit(10)
            );
            /*  SELECT * FROM students LIMIT 10 */
        </pre>

        <p>To remove the previously set limit:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .limit(10)
                    .limit(0)
            );
            /*  SELECT * FROM students */
        </pre>

        <p>To specify the <code>OFFSET</code> of the first row to return:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .offset(102)
            );
            /*  SELECT * FROM students OFFSET 102 */
        </pre>

        <p>Same as for <code>limit()</code>, you can remove a previously set offset:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .offset(1)
                    .offset(0)
            );
            /*  SELECT * FROM students */
        </pre>

    </section>



    <section id="update">
        <a name="update" href="#update"><h2>UPDATE</h2></a>

        <p>To get an instance of the <code>UPDATE</code> query builder:</p>

        <pre class="brush: js">
            var q = squel.update();
        </pre>

        <p>You need to supply at least one table name and one field to update:</p>

        <pre class="brush: js">
            alert(
                squel.update()
                    .table("students")
                    .set("name", "Thomas")
            );
            /*  UPDATE students SET name = "Thomas" */
        </pre>

        <p>Multiple table names can be supplied along with aliases:</p>

        <pre class="brush: js">
            alert(
                squel.update()
                    .table("students")
                    .table("teachers", "t")
                    .set("t.name", "Fred")
            );
            /*  UPDATE students, teachers `t` SET t.name = "Fred" */
        </pre>

        <h3>Field values</h3>

        <p>Not all field values within a query need to be surrounded by quotes. Squel figures out how to represent each
            field value based on its runtime type:</p>

        <pre class="brush: js">
            alert(
                squel.update()
                    .table("students")
                    .set("name", "Fred")
                    .set("age", 29)
                    .set("score", 1.2)
                    .set("graduate", false)
            );
            /*  UPDATE students SET name = "Fred", age = 29, score = 1.2, graduate = FALSE */
        </pre>

        <p>You can even use <code>NULL</code> values:</p>

        <pre class="brush: js">
            alert(
                squel.update()
                    .table("students")
                    .set("name", "Fred")
                    .set("age", 29)
                    .set("nickname", null)
            );
            /*  UPDATE students SET name = "Fred", age = 29, nickname = NULL */
        </pre>

        <p>You can use the <code>usingValuePlaceholders</code> option to stop Squel from automatically placing string
            field values within quotes. This is useful if, for example, you're using parameterized queries:</p>

        <pre class="brush: js">
            alert(
                squel.update({ usingValuePlaceholders: true })
                    .table("students")
                    .set("name", "?")
                    .set("age", 29)
                    .set("nickname", null)
            );
            /*  UPDATE students SET name = ?, age = 29, nickname = NULL */
        </pre>

        <h3>Filtering, sorting and limits</h3>

        <p>The <code>where()</code>, <code>order()</code> and <code>limit()</code> methods are supported the same
            way they are by the <a href="#select">SELECT</a> builder:</p>

        <pre class="brush: js">
            alert(
                squel.update()
                    .table("students")
                    .set("name", "Fred")
                    .set("age", 29)
                    .where("id > 5")
                    .where("id < 102")
                    .order("id", false)
                    .limit(5)
            );
            /*  UPDATE students SET name = "Fred", age = 29 WHERE (id > 5) AND (id < 102) ORDER BY id DESC LIMIT 5 */
        </pre>

    </section>



    <section id="delete">
        <a name="delete" href="#delete"><h2>DELETE</h2></a>

        <p>To get an instance of the <code>DELETE</code> query builder:</p>

        <pre class="brush: js">
            var q = squel.delete();
        </pre>

        <p>You can also use the alias <code>remove()</code>:</p>

        <pre class="brush: js">
            var q = squel.remove();
        </pre>

      <p>You need to supply at least the table name:</p>

        <pre class="brush: js">
            alert(
                squel.delete()
                    .from("students")
            );
            /*  DELETE FROM students */
        </pre>

        <h3>Joins</h3>

        <p>The <code>join()</code> and related methods are supported the same way
          they are by the <a href="#select">SELECT</a> builder:</p>

        <pre class="brush: js">
            alert(
                squel.delete()
                    .from("students", "s")
                    .outer_join("marks", "m", "m.student_id = s.id")
            );
            /*  DELETE FROM students `s` OUTER JOIN marks `m` ON (m.student_id = s.id) */
        </pre>

      <h3>Filtering, sorting and limits</h3>

        <p>The <code>where()</code>, <code>order()</code> and <code>limit()</code> methods are supported the same way
            they are by the <a href="#select">SELECT</a> builder:</p>

        <pre class="brush: js">
            alert(
                squel.delete()
                    .from("students")
                    .where("id > 5")
                    .where("id < 102")
                    .order("id", false)
                    .limit(5)
            );
            /*  DELETE FROM students WHERE (id > 5) AND (id < 102) ORDER BY id DESC LIMIT 5 */
        </pre>

    </section>


    <section id="insert">
        <a name="insert" href="#insert"><h2>INSERT</h2></a>

        <p>To get an instance of the <code>INSERT</code> query builder:</p>

        <pre class="brush: js">
            var q = squel.insert();
        </pre>

        <p>At least the table name and one field must be supplied:</p>

        <pre class="brush: js">
            alert(
                squel.insert()
                    .into("students")
                    .set("name", "Thomas")
            );
            /*  INSERT INTO students (name) VALUES ("Thomas") */
        </pre>

        <p>Squel out how to treat each field value based on its runtime type, same as it does for
            <a href="#update">UPDATE</a> queries:</p>

        <pre class="brush: js">
            alert(
                squel.insert()
                    .into("students")
                    .set("name", "Thomas")
                    .set("age", 29)
                    .set("score", 90.2)
                    .set("graduate", true)
                    .set("nickname", null)
            );
            /*  INSERT INTO students (name, age, score, graduate, nickname) VALUES ("Thomas", 29, 90.2, TRUE, NULL) */
        </pre>

        <p>And same as for <a href="#update">UPDATE</a> queries, you can use the <code>usingValuePlaceholders</code> option to
            stop Squel from automatically placing string field values within quotes:</p>

        <pre class="brush: js">
            alert(
                squel.insert({ usingValuePlaceholders: true })
                    .into("students")
                    .set("name", "?")
                    .set("age", 29)
                    .set("score", 90.2)
                    .set("graduate", true)
                    .set("nickname", null)
            );
            /*  INSERT INTO students (name, age, score, graduate, nickname) VALUES (?, 29, 90.2, TRUE, NULL) */
        </pre>

    </section>


    <section id="autoquotes">
      <a name="autoquotes" href="#autoquotes"><h2>Automatic quotes</h2></a>

      <p>By default Squel does not add quotes around table names and field names. But you can tell it to do so using the
        <code>autoQuoteTableNames</code> and <code>autoQuoteFieldNames</code> options:</p>

      <pre class="brush: js">
        alert(
          squel.select({ autoQuoteTableNames: true, autoQuoteFieldNames: true })
            .from("students")
            .field("name", "Student name")
        );

        /*   SELECT `name` AS "Student name" FROM `students`  */
      </pre>

      <p>You can also customize the quote character using the <code>nameQuoteCharacter</code> option:</p>

      <pre class="brush: js">
        alert(
          squel.select({ autoQuoteTableNames: true, autoQuoteFieldNames: true, nameQuoteCharacter: '|' })
            .from("students")
            .field("name", "Student name")
        );

        /*   SELECT |name| AS "Student name" FROM |students|  */
      </pre>

      <p>As you can see above, Squel does however automatically add quotes to alias names. These too can be customized:</p>

      <pre class="brush: js">
        alert(
          squel.select({ tableAliasQuoteCharacter: '|', fieldAliasQuoteCharacter: '~' })
            .from("students", "s")
            .field("name", "Student name")
        );

        /*   SELECT name AS ~Student name~ FROM students |s|  */
      </pre>

      <p>And you can turn off automatic alias quoting if you so desire:</p>

      <pre class="brush: js">
        alert(
          squel.select({ autoQuoteAliasNames: false })
            .from("students", "s")
            .field("name", "Student_name")
        );

        /*   SELECT name AS Student_name FROM students s  */
      </pre>

    </section>


    <section id="expressions">
        <a name="expressions" href="#expressions"><h2>Expressions</h2></a>

        <p>Squel lets you use use complex expressions strings in <code>WHERE</code> and <code>ON</code> clauses. For
            example:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .from("students")
                    .where("(id < 500 AND (id > 100 OR name <> 'Thomas') AND "
                            + "(age BETWEEN 20 AND 25 OR (name <> 'Fred'))) OR (nickname = 'Hardy')")
            );
            /*  SELECT * FROM students WHERE
                    ((id < 500 AND (id > 100 OR name <> 'Thomas') AND (age BETWEEN 20 AND 25 OR (name <> 'Fred')))
                        OR (nickname = 'Hardy')) */
        </pre>

        <p>But having to change an expression string like that later on will be error-prone. It would be nice if you could build it
            the same way you build queries. Luckily Squel provides an expression builder just for this purpose. To
            get an instance of the builder:</p>

        <pre class="brush: js">
            var q = squel.expr();
        </pre>

        <p>To build the above expression string these are the calls you would make:</p>

        <pre class="brush: js">
            alert(
                squel.expr()
                    .and("id < 500")
                    .and_begin()
                        .or("id > 100")
                        .or("name <> 'Thomas'")
                    .end()
                    .and_begin()
                        .or("age BETWEEN 20 AND 25")
                        .or("name <> 'Fred'")
                    .end()
                    .or("nickname = 'Hardy'")
            );
            /*  id < 500 AND (id > 100 OR name <> 'Thomas') AND (age BETWEEN 20 AND 25 OR name <> 'Fred')
                    OR nickname = 'Hardy'
            */
        </pre>

        <p>Straight away the benefit of using the expression builder can be seen as it has simplified the
            expression (<code>AND</code> has precendence over <code>OR</code>). Not to mention that it's easier to
            figure out the meaning of the expression looking at this code than from the big string we were
            using earlier.</p>

        <p>As a convenience expression builder instances can be used in calls to <code>where()</code> and
            <code>join()</code> when using the query builders:</p>

        <pre class="brush: js">
            alert(
                squel.select()
                    .field("s.id")
                    .from("students", "s")
                    .where(
                        squel.expr()
                            .and("s.name <> 'Fred'")
                            .or_begin()
                                .or("s.id = 5")
                                .or("s.id = 6")
                            .end()
                    )
                    .join("teachers", "t",
                        squel.expr()
                            .and("s.id = t.sid")
                            .and("t.name = 'Frances'")
                    )
            );
            /*
                SELECT s.id FROM students `s`
                    INNER JOIN teachers `t` ON (s.id = t.sid AND t.name = 'Frances')
                        WHERE (s.name <> 'Fred' AND (s.id = 5 OR s.id = 6))
            */
        </pre>

    </section>

    <section id="cloning">
      <a name="cloning" href="#cloning"><h2>Cloning</h2></a>

      <p>You can create a copy of a query builder instance using its <code>clone()</code> method. For example:</p>

      <pre class="brush: js">
          var select1 = squel.select().from('students');

          var select2 = select1.clone().field('id').where('name = "david"');

          alert( select1 );

          /* SELECT * FROM students */

          alert( select2 );

          /* SELECT id FROM students WHERE (name = "david") */
      </pre>

      <p>Here is an example using an <code>INSERT</code> builder:</p>

      <pre class="brush: js">
          var ins = squel.insert().into('students').set('name', 'David');

          var insMathew = ins.clone().set('name', 'Mathew');

          var insMark = insMathew.clone().set('name', 'Mark');

          alert( insMathew );

          /* INSERT INTO students (name) VALUES('Mathew') */

          alert( insMark );

          /* INSERT INTO students (name) VALUES('Mark') */
      </pre>

    </section>

    <section id="custom">
      <a name="custom" href="#custom"><h2>Custom queries</h2></a>

      <p>You can customize Squel's query building mechanism quite easily. For instance, if you wanted to add
        <code>OFFSET</code> clauses to <code>UPDATE</code> queries you could do it as such:</p>

      <pre class="brush: js">
        /* We create a convenience method to make it easy to instantiate our customized UPDATE builder */
        squel.myupdate = function(options) {
          return squel.update(options, [
            new squel.cls.StringBlock(options, 'UPDATE'),
            new squel.cls.UpdateTableBlock(options),
            new squel.cls.SetFieldBlock(options),
            new squel.cls.WhereBlock(options),
            new squel.cls.OrderByBlock(options),
            new squel.cls.OffsetBlock(options),
            new squel.cls.LimitBlock(options)
          ]);
        };

        alert(
          squel.myupdate()
            .table('students')
            .set('status', 'active')
            .limit(10)
            .offset(2)
        );

        /* UPDATE students SET status = 'active' OFFSET 2 LIMIT 10 */
      </pre>

      <p>Hopefully you can see that it is possible to totally override the built-in query building logic. Also notice
        that each <em>building block</em> within a query can have a different set of <code>options</code> applied to it.
      Check out <a href="https://github.com/hiddentao/squel/blob/master/src/squel.coffee">squel.coffee</a> to see
        the available building blocks.</p>

      <p>You can also build other types of queries and query clauses not already included in Squel. Let's say
        you wanted to build a query structured as follows: <code>PRAGMA {command} {param}</code>:</p>

      <pre class="brush: js">
        /* OOP Inheritance mechanism (substitute your own favourite library for this!) */
        Function.prototype.inheritsFrom = function( parentClassOrObject ) {
          this.prototype = new parentClassOrObject;
          this.prototype.constructor = this;
          this.prototype.parent = parentClassOrObject.prototype;
        };


        /* Create the 'command' clause */

        var CommandBlock = function() {};
        CommandBlock.inheritsFrom(squel.cls.Block);

        /* methods prefixed with '_' are private and will not get exposed within the query builder */
        CommandBlock.prototype._command = function(command) {
          this.command = command;
        };

        /* this method will get exposed within the query builder */
        CommandBlock.prototype.flush = function() {
          this._command('flush');
        };

        /* output the query clause */
        CommandBlock.prototype.buildStr = function() {
          return this.command.toUpperCase();
        };


        /* Create the 'param' clause */

        var ParamBlock = function() {};
        ParamBlock.inheritsFrom(squel.cls.Block);

        ParamBlock.prototype.param = function(p) {
          this._p = p;
        };

        ParamBlock.prototype.buildStr = function() {
          return this._p;
        };


        /* Create the 'PRAGMA' query builder */

        var PragmaQuery = function(options) {
          this.parent.constructor.call(this, options, [
              new squel.cls.StringBlock(options, 'PRAGMA'),
              new CommandBlock(),
              new ParamBlock()
          ]);
        };
        PragmaQuery.inheritsFrom(squel.cls.QueryBuilder);


        /* Create squel.pragma() convenience method */

        squel.pragma = function(options) {
          return new PragmaQuery(options)
        };


        /* Try it out! */

        alert(
          squel.pragma()
            .flush()
            .param('students')
        );

        /* 'PRAGMA FLUSH students' */
      </pre>


    </section>

    <section id="tests" class="white_text">
        <a name="tests" href="#tests"><h2>Tests</h2></a>

        <p>
            Tests are written as <a href="http://vowsjs.org/">vows</a> and can be found in the <code>test/</code> folder when you checkout the
            <a href="https://github.com/hiddentao/squel">source code</a>.
            To run them do the following:
        </p>

        <pre class="brush: shell">
            $ npm install
            $ make test
        </pre>

        <p>If the tests pass you should see something like this:</p>

        <pre class="brush: shell">
                &#10003; OK &raquo; 320 honored (0.236s)
        </pre>

        <p>
            The tests get automatically run by the <em>Travis CI</em>
            build system every time changes are made to Squel.

            The current build status is: <a class="img" href="http://travis-ci.org/hiddentao/squel" title="View squel on Travis"><img alt="Build Status" src="https://secure.travis-ci.org/hiddentao/squel.png"></a>
        </p>

    </section>

    <footer class="white_text">
        Developed by <a href="http://www.hiddentao.com/">Ramesh Nair</a> aka <a href="http://twitter.com/hiddentao">@hiddentao</a>. Source on <a href="https://github.com/hiddentao/squel">Github</a>.
    </footer>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="https://rawgithub.com/hiddentao/squel/master/squel.min.js"></script>
    <script type="text/javascript" src="public/js/shCore.js"></script>
    <script type="text/javascript" src="public/js/shBrushBash.js"></script>
    <script type="text/javascript" src="public/js/shBrushXml.js"></script>
    <script type="text/javascript" src="public/js/shBrushJScript.js"></script>
    <script type="text/javascript">
        $(document).ready(function(){
            // highlight code blocks
            SyntaxHighlighter.defaults['gutter'] = false;
            SyntaxHighlighter.defaults['toolbar'] = false;
            SyntaxHighlighter.highlight();

            // nav menus
            handleNavMenus();

            // allow viewer to execute highlighted js code blocks
            enableRunnableSections();
        });
        function enableRunnableSections() {
            $(".syntaxhighlighter").each(function(){
                var elem = $(this);
                var code = $("table", elem).text();
                if (elem.hasClass("js") && 0 <= code.indexOf("alert")) {
                    elem.addClass("executable").attr("title", "Click to run");
                    elem.click(function(e) {
                        e.preventDefault();
                        eval(code);
                    });
                }
            });
        }
        function handleNavMenus() {
            $("ul.submenu").each(function(){
                var submenu = $(this);
                submenu.hide();
                var parentItem = submenu.parent();
                parentItem.mouseenter(function(){
                    submenu.css({
                        "position": "absolute",
                        "top": (parentItem.offset().top - $(window).scrollTop() + parentItem.height() + 15) + "px",
                        "left": (parentItem.offset().left) + "px"
                    }).show();
                }).mouseleave(function(){
                    submenu.hide();
                });
            });
        }
    </script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-11640584-5']);
      _gaq.push(['_setDomainName', 'squeljs.org']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body>
</html>
